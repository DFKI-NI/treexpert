import datetime
from typing import Dict, List, Union

from ninja import Path, Query, Router, Schema
from ninja.orm import create_schema

from django.shortcuts import get_object_or_404

from .models import Color, Tree, TreeKind, TreeLeaf, TreeNode, Version

router = Router(tags=["tree"])


# === /colors === get all colors =============================================
ColorOut = create_schema(Color, name="ColorOut", fields=["id", "name"])
ColorIn = create_schema(Color, name="ColorIn", fields=["name"])


@router.get("/colors", response=List[ColorOut])
def colors(request):
    """
    Retrieves all available colors that are saved in the database.
    """
    return Color.objects.all()


@router.post("/color/new", response={200: ColorOut})
def color_new(request, color: ColorIn):
    """
    Use this endpoint to create a new color. Colors only need a name as a
    property. Their actual representation is left to the frontend using this
    API.
    """
    new_color = Color.objects.create(**color.dict())
    return 200, new_color


@router.put("/color/update/{id}")
def update_color(request, id: int, color: ColorIn):
    """
    Change the name of a color. Colors can not be deleted.
    """
    c = get_object_or_404(Color, id=id)
    old = c.name
    c.name = color.name
    c.save()
    return "successfully updated color " + str(id) + " from " + old + " to " + c.name


# === /kind/all === get all kinds of trees ===================================
TreeKindOut = create_schema(TreeKind, name="TreeKindOut")
TreeKindIn = create_schema(TreeKind, name="TreeKindIn", exclude=["id"])


@router.get("/kind/all", response=List[TreeKindOut])
def all_kinds(request):
    """
    Retrieve all kinds of trees that are currently available in the database.
    """
    return TreeKind.objects.all()


@router.post("/kind/new", response={200: TreeKindOut})
def new_tree_kind(request, kind: TreeKindIn):
    """
    Create a new kind of tree. A tree kind needs a **name** and a **description**.
    For referencing the id then generated by the system is used. The name and
    description are only for human readable purposes.
    """
    new_kind = TreeKind.objects.create(**kind.dict())
    return 200, new_kind


@router.put("/kind/{id}")
def update_tree_kind(request, id: int, tree_kind: TreeKindIn):
    """
    Change the name or description of a tree kind.
    """
    kind = get_object_or_404(TreeKind, id=id)
    old_name = kind.name
    kind.name = tree_kind.name
    old_desc = kind.description
    kind.description = tree_kind.description
    kind.save()
    return (
        "successfully updated tree kind "
        + str(id)
        + " from "
        + old_name
        + ", "
        + old_desc
        + " to "
        + kind.name
        + ", "
        + kind.description
    )


@router.delete("/kind/{id}", response={200: str, 409: str})
def delete_tree_kind(request, id: int):
    """
    Deletes a tree kind only if this tree kind doesn't have any trees.
    """
    tree_kind = get_object_or_404(TreeKind, id=id)

    trees = Version.objects.filter(kind_of_tree=id)
    if trees.count() == 0:
        tree_kind.delete()
        return 200, "ok"
    else:
        return (
            409,
            "cannot delete this tree kind, since there is already a tree of its kind.",
        )


# === /all === get all trees =================================================
ShortTreeOut = create_schema(Tree, name="ShortTreeOut", depth=1, exclude=["root"])


@router.get("/all", response=List[ShortTreeOut])
def all_trees(request):
    """
    Retrieve all trees that are stored in the database. This includes trees from
    all kinds, current and old trees.
    """
    return Tree.objects.all()


# === /latest === get current tree ===========================================
TreeLeafOut = create_schema(
    TreeLeaf,
    name="TreeLeafOut",
    exclude=["tree_version"],
)

TreeNodeOut = create_schema(
    TreeNode,
    name="TreeNodeOut",
    exclude=["tree_version", "true_successor", "false_successor"],
)


class TreeOut(Schema):
    id: int
    created_by: str
    root: int
    nodes: List[TreeNodeOut]
    leafs: List[TreeLeafOut]
    version: str
    date_created: str
    kind_of_tree: int


@router.get("/latest", response={200: TreeOut, 204: None})
def tree(request, kind_id: int = None):
    """
    Retrieve the latest tree for a specific tree kind. If no tree kind is given, the
    default kind with id=1 is used. This gives you all the information that there is
    about this specific tree and its nodes and leaves.

    For a description of most properties of nodes and leaves, please see
    /tree/new/{kind_id}. To correctly save the nodes in the database, two properties
    are added: true_type and false_type. They specify what kind of object succeeds this
    node if the comparison yields true or false. This can either be another node or a
    leaf. For a node, the true/false_type values is 4, for a leaf, the true/false_type
    is 5. This has internal reasons on how Django processes generic properties in the
    database.
    """
    complete_tree = None
    tree_kind = (
        TreeKind.objects.first()
        if kind_id is None
        else TreeKind.objects.get(id=kind_id)
    )

    complete_tree = Tree.objects.get_current_complete_tree(kind_of_tree=tree_kind)
    if complete_tree is None:
        return 204, None
    out = TreeOut(
        id=complete_tree[0].id,
        created_by=complete_tree[0].created_by,
        root=complete_tree[0].root.number,
        nodes=list(complete_tree[1]),
        leafs=list(complete_tree[2]),
        version=str(complete_tree[3]),
        kind_of_tree=complete_tree[3].kind_of_tree.id,
        date_created=str(complete_tree[0].date_created),
    )
    return 200, out


# === /id === get specific tree ==============================================
@router.get("/id/{id}", response={200: TreeOut, 204: None})
def tree_id(request, id):
    """
    Retrieve a tree with a specific id. See /tree/latest for more information on how
    this tree looks like.
    """
    trees = Tree.objects.filter(id=id)
    complete_tree = Tree.objects.get_complete_tree(trees[0].tree_version)
    if complete_tree is None:
        return 204, None
    print(complete_tree[3].kind_of_tree.id)
    out = TreeOut(
        id=complete_tree[0].id,
        created_by=complete_tree[0].created_by,
        root=complete_tree[0].root.number,
        nodes=list(complete_tree[1]),
        leafs=list(complete_tree[2]),
        version=str(complete_tree[3]),
        kind_of_tree=complete_tree[3].kind_of_tree.id,
        date_created=str(complete_tree[0].date_created),
    )
    return 200, out


# === /explanation === get current trees explanation =========================
class QueryVersion(Schema):
    kind_of_tree: int = None
    major: int = None
    minor: int = None


TreeLeafExplanation = create_schema(
    TreeLeaf,
    name="TreeLeafExplanation",
    exclude=["number", "tree_version", "date_created"],
)

TreeNodeExplanation = create_schema(
    TreeNode,
    name="TreeNodeExplanation",
    exclude=[
        "number",
        "tree_version",
        "date_created",
        "true_type",
        "true_id",
        "true_successor",
        "false_type",
        "false_id",
        "false_successor",
    ],
)


class TreeExplanations(Schema):
    version: str
    nodes: List[TreeNodeExplanation]
    leafs: List[TreeLeafExplanation]


@router.get("/explanation", response={200: TreeExplanations, 204: None, 400: str})
def tree_explanation(request, whichversion: QueryVersion = Query(...)):
    """
    This is a special endpoint specifically for the frontend that displays the
    decision/recommendation to the user. It retrieves a complete tree with just
    the information used to show the explanations of the path to the decision.
    If no tree kind is specified, the default tree kind with id=1 is used.
    """
    if (
        whichversion.major is None
        and whichversion.minor is not None
        or whichversion.major is not None
        and whichversion.minor is None
    ):
        return 400, "Please specify major and minor or neither."

    complete_tree = None
    # use default tree kind if none is specified otherwise get the specified one
    tree_kind = (
        TreeKind.objects.first()
        if whichversion.kind_of_tree is None
        else TreeKind.objects.get(id=whichversion.kind_of_tree)
    )

    if whichversion.major is None and whichversion.minor is None:
        complete_tree = Tree.objects.get_current_complete_tree(kind_of_tree=tree_kind)
    else:
        complete_tree = Tree.objects.get_complete_tree(
            version=Version.objects.get(
                kind_of_tree=tree_kind,
                major=whichversion.major,
                minor=whichversion.minor,
            )
        )

    if complete_tree is None:
        return 204, None
    response = TreeExplanations(
        version=str(complete_tree[3]),
        nodes=list(complete_tree[1]),
        leafs=list(complete_tree[2]),
    )
    return 200, response


# === /year/month/day === get tree at specific date ==========================
class PathDate(Schema):
    year: int
    month: int
    day: int

    def value(self):
        return datetime.date(self.year, self.month, self.day)


@router.get("/{int:year}/{int:month}/{int:day}", response={418: str})
def tree_at(request, date: PathDate = Path(...), kind_id: int = None):
    """
    Not yet implemented.
    """
    return (
        418,
        "this is not implemented yet, you requested the tree for: " + str(date.value()),
    )


# === /new === post new tree =================================================
class TreeLeafIn(Schema):
    number: int
    display_name: str
    result: bool
    color_id: int = None


class TreeNodeIn(Schema):
    number: int
    display_name: str
    description: str
    data_type_id: int
    data_value: Union[int, str, bool, list]
    comparison: str
    list_comparison: str = "ALL"
    explanation: str = ""
    true_number: int
    true_explanation: str = ""
    true_color_id: int = None
    false_number: int
    false_explanation: str = ""
    false_color_id: int = None


class NewTree(Schema):
    created_by: str
    new_major_version: bool
    root: int
    nodes: List[TreeNodeIn]
    leafs: List[TreeLeafIn]


def build_nodes(
    to_create: int,
    elements: Dict[int, Union[TreeLeafIn, TreeNodeIn]],
    version: Version,
):
    if type(elements[to_create]) is TreeNodeIn:
        true = build_nodes(elements[to_create].true_number, elements, version)
        false = build_nodes(elements[to_create].false_number, elements, version)
        node_dict = elements[to_create].dict()
        del node_dict["true_number"]
        del node_dict["false_number"]
        node = TreeNode(
            true_successor=true[0],
            false_successor=false[0],
            tree_version=version,
            **node_dict,
        )
        return [node] + true + false
    elif type(elements[to_create]) is TreeLeafIn:
        leaf = TreeLeaf(
            tree_version=version,
            **elements[to_create].dict(),
        )
        return [leaf]


def save_nodes(nodes):
    for node in nodes:
        node.save(force_insert=True)
    return None


def check_lens(node, payload):
    same_length = False
    n_nodes = TreeNode.objects.filter(tree_version=node.tree_version)
    n_leafs = TreeLeaf.objects.filter(tree_version=node.tree_version)
    if len(n_nodes) == len(payload.nodes) and len(n_leafs) == len(payload.leafs):
        same_length = True
    return same_length


def delete_nodes(version):
    TreeLeaf.objects.filter(tree_version=version).delete()
    TreeNode.objects.filter(tree_version=version).delete()
    version.delete()
    return None


def validate_tree(tree, payload):
    if int(tree.root.number) == payload.root:
        if check_lens(tree.root, payload):
            tree.tree_version.valid = True
            tree.tree_version.save()
            return True, "All good"
        else:
            return False, (
                "number of saved nodes/leafs not like in query.\n"
                "Probably query has two 'roots'.\n"
            )
    else:
        return False, "root problem\n"


@router.post("/new/{int:kind_id}", response={200: ShortTreeOut, 400: str})
def new_tree(request, payload: NewTree, kind_id: int = Path(...)):
    """
    Create a new tree. After specifying the id of the tree kind you want to add the
    tree to, you need to enter the **nodes** and **leaves** and also some general
    information about the tree:
    * **created_by**: a string to identify the person or algorithm that has created
    this tree
    * **new_major_version**: whether you want to make the new version step up to the
    next major or minor one (1.2 to 1.3 or 1.2 to 2.0)
    * **root**: which of the nodes is the root (int)

    Each node should then include:
    * **number**: temporary primary key of this node to reference it in the root
    property or in other nodes
    * **display_name** and **description**: describe your node to the user
    * **data_type_id**: which datatype is compared in this node?
    * **data_value**: and what is its value?
    * **comparison**: specify how to compare (EQ=equal, NE=not equal, GT=greater than,
    ST=smaller than)
    * **list_comparison**: when receiving more than one input value to compare to the
    data_value, do all or just some values need to render true in the comparison (ALL,
    ONE, TWO)
    * **true/false_number**: reference to the successor (node or leaf) if the
    comparison renders true/false
    * **true/false_color_id**: give a color to this successor (see /tree/colors)
    * **explanation** and **true/false_explanation**: add an explanation to the node
    itself and to its successors

    Each leaf should include:
    * **number**: also for temporarily referencing that leaf
    * **display_name**: description for the user about this leaf/recommendation
    * **result**: if the tree has a yes/no answer, this is your answer
    * **color_id**: optional to give the user a color hint about this result

    The nodes and leaves should form a sound binary tree. If they don't (extra leaves
    or nodes, more than one tree, ...), this endpoint will give you back an error
    stating the problem.
    """
    print(TreeKind.objects.first())
    tree_kind = TreeKind.objects.get(id=int(kind_id))
    version = Version.objects.create_next_version(
        kind_of_tree=tree_kind, isMajor=payload.new_major_version
    )
    tree_dict = dict()
    for element in payload.nodes + payload.leafs:
        if element.number in tree_dict:
            return 400, (
                "You have assigned number = "
                + str(element.number)
                + " to several elements"
            )
        else:
            tree_dict[element.number] = element
    try:
        # Save only single occurences list -> fromkeys -> list
        # case multiple nodes point to the same object
        nodes = list(dict.fromkeys(build_nodes(payload.root, tree_dict, version)))
    except KeyError as e:
        version.delete()
        return 400, (
            "You referenced " + str(e) + " as successor of a node, "
            "but you didn't define a Leaf or Node with that number.\n"
            "Change what is wrong and try again!"
        )
    except RecursionError:
        return 400, (
            "RecursionError: There is a endless recursion loop in your tree.\n"
            "Change what is wrong and try again!"
        )
    else:
        save_nodes(nodes)
        tree = Tree(created_by=payload.created_by, root=nodes[0], tree_version=version)
        valid, message = validate_tree(tree, payload)
        if valid:
            tree.save(force_insert=True)
            return 200, tree
        else:
            delete_nodes(version)
            return 400, (
                message + "The tree could not be validated and saved correctly.\n"
                "Change what is wrong and try again!"
            )
